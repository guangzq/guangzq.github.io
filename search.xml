<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Activity的启动过程之startActivit源码解析]]></title>
      <url>%2F2017%2F03%2F15%2FActivity%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B9%8BstartActivity%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[一.概述本文基于api 24 startActivity简化版流程图 二.源码解析以startActivity为入口 方法：Activity-&gt;startActivity 12345678910111213141516171819@Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125;@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125; &#125; public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null); &#125; 最终方法都是调用的startActivityForResult，继续看： 方法：Acticity-&gt;startActivityForResult 12345678910111213141516171819202122232425262728293031323334353637383940public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //mParent常用于ActivityGroup,但是ActivityGroup已废弃，所以一般的Activity都是走这里 if (mParent == null) &#123; //启动一个新的Activity,核心功能位于mMainThread.getApplicationThread()。Instrumentation类是用于监视system和application交互的类。在最终启动activity //的地方会用到Instrumentation Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; //发送调用onActivityResult的消息 mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. //这段主要是讲：在result接收到之前避免acitity出现，在onCreate或者onResume期间设置可以是acticity隐藏，避免闪烁 mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; //ActitityGroup内部的Activity则会走这里，实现方式其实是一样的 if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; &#125; 既然真正执行打开Activity是在execStartActivity实现的，那么继续看execStartActivity 方法：Instrumentation-&gt;execStartActivity 12345678910111213141516171819202122232425262728293031323334353637383940414243public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; Uri referrer = target != null ? target.onProvideReferrer() : null; if (referrer != null) &#123; intent.putExtra(Intent.EXTRA_REFERRER, referrer); &#125; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; //遍历ActivityMonitor,看是否存在这个Activity final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; //如果//当该monitor阻塞activity启动,也就是目标Activity无法打开就直接return if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; //如果存在就跳出循环 break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); //真正的startActivity的方法，其实核心功能在whoThread的scheduleLaunchActivity完成的 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //用于检查打开Activity异常的方法，比如常见的Activity没在AndroidManifest的话， // 会抛出“...have you declared this activity in your AndroidManifest.xml?”异常 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(&quot;Failure from system&quot;, e); &#125; return null; &#125; 补充checkStartActivityResult方法，内部实现是各种情况下需要抛出的异常信息 1234567891011121314151617181920212223242526272829303132333435363738394041public static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( &quot;Unable to find explicit activity class &quot; + ((Intent)intent).getComponent().toShortString() + &quot;; have you declared this activity in your AndroidManifest.xml?&quot;); throw new ActivityNotFoundException( &quot;No Activity found to handle &quot; + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException(&quot;Not allowed to start activity &quot; + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( &quot;FORWARD_RESULT_FLAG used while also requesting a result&quot;); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( &quot;PendingIntent is not an activity&quot;); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( &quot;Starting under voice control not allowed for: &quot; + intent); case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION: throw new IllegalStateException( &quot;Session calling startVoiceActivity does not match active session&quot;); case ActivityManager.START_VOICE_HIDDEN_SESSION: throw new IllegalStateException( &quot;Cannot start voice activity on a hidden session&quot;); case ActivityManager.START_CANCELED: throw new AndroidRuntimeException(&quot;Activity could not be started for &quot; + intent); default: throw new AndroidRuntimeException(&quot;Unknown error code &quot; + res + &quot; when starting &quot; + intent); &#125; &#125; 接上文的startActivity，是定义在接口IActivityManager的方法，该方法的实现类是定义在ActivityManagerNative类的内部类ActivityManagerProxy 方法：ActivityManagerProxy-&gt;startActivity 123456789101112131415161718192021222324252627282930313233public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; 参数众多，这里重点关注IApplicationThread参数，是个接口，关键方法scheduleLaunchActivity，实现和继承如下： 12public abstract class ApplicationThreadNative extends Binder implements IApplicationThreadprivate class ApplicationThread extends ApplicationThreadNative 方法：ActivityThread-&gt;ApplicationThread-&gt;scheduleLaunchActivity 1234567891011121314151617181920212223242526272829303132333435@Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 这个方法主要是用来记录activity的各种参数，然后发送启动activity的消息，接着看这一消息的实现 12345678910111213141516171819202122private class H extends Handler &#123; ... public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //处理LAUNCH_ACTIVITY的消息 handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; ... &#125;``` **真正的处理启动Activity的逻辑来了**方法：ActvityThread-&gt;performLaunchActivity private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { // System.out.println(“##### [“ + System.currentTimeMillis() + “] ActivityThread.performLaunchActivity(“ + r + “)”); //解析启动Activity的相关信息，包括component和packageInfo ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) { r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); }123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136``` ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //通过ClassLoader将目标activity加载进来，并实例化一个activity对象 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125; try &#123; //创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) &#123; //创建activity的上下文信息 Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; //将context和activity的相关信息通过attach设置到目标activity中去 activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; //通过mInstrumentation的callActivityOnCreate来间接调用目标activity的onCreate方法 mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPostCreate()&quot;); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( &quot;Unable to start activity &quot; + component + &quot;: &quot; + e.toString(), e); &#125; &#125; return activity; &#125; performLaunchActivity的主要逻辑有三点： 解析启动Activity的相关信息，包括component和packageInfo 通过ClassLoader将目标activity加载进来，并实例化一个activity对象 通过mInstrumentation的callActivityOnCreate来间接调用目标activity的onCreate方法，然后就是走activity的声明周期了 3.总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用RxJava解决实际问题]]></title>
      <url>%2F2017%2F02%2F17%2F%E4%BD%BF%E7%94%A8RxJava%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[RxJava学习有段时间了，项目中也有许多场景用到，比如防止多次点击，最近有个场景，日志的压缩上传，首先需要考虑压缩与上传不能同步执行，而且都需要在io线程中操作，并且要等待压缩后才能上传，获取不到压缩结束的状态，所以考虑压缩这一操作所在的线程结束，也就意味着压缩的结束，然后再执行上传操作，一开始是这样写的： 12345678910111213Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; //TODO 压缩 &#125; &#125;); thread.start(); try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //TODO 上传操作 此处用join表示执行完子线程再向下执行，然而却造成了anr,应该是线程阻塞引起的 考虑到RxJava正是以异步著称的库，就是就改用RxJava来实现，用trampoline来实现这一需求再好不过了 Schedulers.trampoline( )当其它排队的任务完成后，在当前线程排队开始执行 用RxJava实现的代码 12345678910Scheduler scheduler = Schedulers.trampoline(); Scheduler.Worker worker = scheduler.createWorker(); worker.schedule(() -&gt; Schedulers.io().createWorker().schedule(() -&gt; &#123; L.line(&quot;start_zip&quot;); //TODO 压缩 worker.schedule(() -&gt; &#123; L.line(&quot;ziping&quot;); //TODO 上传操作 L.line(&quot;zip_end&quot;); &#125;)); 后记RxJava是个异步解决复杂流程的极好的库，是时候总结一波了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何手动安装gradle]]></title>
      <url>%2F2017%2F02%2F14%2F%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85gradle%2F</url>
      <content type="text"><![CDATA[在运行lottie-android时，项目导不进AS中，推测应该是电脑本地中没有所需的gradle版本，在线下载太慢，所以选择离线安装，安装步骤如下 下载gradlehttps://services.gradle.org/distributions下载所需版本 配置方法项目一导入就已经在下载gradle了，这时候中断导入，强制关闭AS，然后后在 ~\.gradle\wrapper\dists相应的gradle版本下生成两个文件，将后缀为.part的文件删除，将所下载的.zip放在该目录下注意不要解压 后记lottle-android是一个优秀的安卓动画解决方案，动画流畅而且效率较高，唯一的难点是UI设计师需要设计出优秀的动画从而形成json]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录开发中遇到的错误以及注意点]]></title>
      <url>%2F2014%2F03%2F21%2F%E8%AE%B0%E5%BD%95%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
      <content type="text"><![CDATA[前言建立这篇的博文是为了记录开发中常见的错误以及注意点，一遍后面再遇到相同的错误时可以不用再浪费时间 NavigationTabBar底部导航栏有个比较好用的第三方库NavigationTabBar,其中几个需要注意的细节 Badge的位置给了三种，分别是left(25%), center(50%) and right(75%),当应用right显示却是错位的，可以修改 1private final static float RIGHT_FRACTION = 0.75F; WebView在使用WebView时候，会出现网页加载空白，要添加下面三行代码 123webView.setWebChromeClient(new WebChromeClient());webView.setWebViewClient(new WebViewClient());webView.getSettings().setJavaScriptEnabled(true); 其中，WebViewClient 主要提供网页加载各个阶段的通知，比如网页开始加载onPageStarted，网页结束加载onPageFinished等；WebChromeClient主要提供网页加载过程中提供的数据内容，比如返回网页的title,favicon等，setJavaScriptEnabled表示能够执行Javascript脚本 多人协作项目时，改代码要注意所有引用此处的地方，以免造成bugxml中，View写成view编译会报错的环信IncompatibleClassChangeError的问题项目中环信sdk由v2.3.2升级到v2.3.3的时候报这个错 12Fatal Exception: java.lang.IncompatibleClassChangeErrorThe method &apos;int com.google.android.gms.common.d.a(android.content.Context)&apos; was expected to be of type static but instead was found to be of type virtual (declaration of &apos;java.lang.reflect.ArtMethod&apos; appears in /system/framework/core-libart.jar) 其实debug版本没有问题，是在release版本中报的错，所以估计是配置混淆的问题，经过一番google,确定要在混淆文件中添加 12-keep class com.google.android.gms.** &#123; *; &#125;-dontwarn com.google.android.gms.** 测试没有问题！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac上搭建基于GitHub Page的Hexo博客]]></title>
      <url>%2F2014%2F01%2F20%2FMac%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8EGitHub-Page%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[概述 最近一直想搭建自己的独立博客，在看了好多教程和踩坑之后，终于把博客搭建起来了，博客是基于Hexo+npm+git搭建的，建议之前还是有点基础比较好，要不然环境的搭建就比较麻烦 环境准备 git Node.js Hexo 步骤Node.js用来生成静态页面,从官网下载的会报错，所以建议使用淘宝的npm源在brew命令（以下命令都是基于brew） 1npm install -g cnpm --registry=https://registry.npm.taobao.org git用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述 HexoNode.js和git都配置好之后，就可以安装Hexo了，执行命令 1sudo npm install -g hexo 初始化终端cd到一个你选定的目录，执行hexo init命令： 1hexo init blog blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm： 1npm install 执行如下命令，开启hexo服务器： 1hexo s 优化细节图片如何调整大小在markdown语法中，一个方法之一是可以通过使用img标签 1&lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt; Mac下如何自动打开MarkDown编辑器 首先在Hexo目录下的scripts目录中创建一个JavaScript脚本文件。如果没有这个scripts目录，则新建一个。名字任取。 在所创建的脚本.js中写入： 123456789var exec = require(&apos;child_process&apos;).exec;// Hexo 2.x 用户复制这段hexo.on(&apos;new&apos;, function(path)&#123; exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + path);&#125;);// Hexo 3 用户复制这段hexo.on(&apos;new&apos;, function(data)&#123; exec(&apos;open -a &quot;markdown编辑器绝对路径.app&quot; &apos; + data.path);&#125;); 不用通过hexo g就可以立即生效，可以创建一个文件试一下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这是我的第一篇博客]]></title>
      <url>%2F2014%2F01%2F01%2F%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[积跬步而至千里，这是我新创建的Hexo博客 技术积累一点一滴，稳扎稳打，步步为营 后记更多精彩，请关注我的博客]]></content>
    </entry>

    
  
  
</search>
